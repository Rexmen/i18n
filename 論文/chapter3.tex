\chapter{研究方法與實作}
本章將詳述如何針對i18n工具現存的四項問題，進行思考與改善，並點出與朱峻平的論文「支援多國語言的Robot Framework網頁自動化驗收測試」(第一版i18n工具)的不同之處。

%3.1
\section{系統擴充}
新版i18n系統類別圖(如圖~\ref{新版i18n系統類別圖})，沿用第一版i18n工具的架構(如圖~\ref{1stI18nClassDiagram})，經過部分實作的改善，並且新增了一個用於顯示一詞多譯選項的圖形化使用者介面類別(UI)，以及20種代理關鍵字的類別。(新增的類別在圖中以紅色方框標示)

\begin{figure}[H]
\flushleft
\includegraphics[width= 180mm]{../UML/i18n class diagram-i18n class diagram.png}
\caption{新版i18n系統類別圖}
\label{新版i18n系統類別圖}
\end{figure}

本論文新增的UI類別會在程式執行期間，記錄下遭遇到一詞多譯的詞語以及其翻譯。在程式執行後，產生一詞多譯的UI；使用者選擇並提交希望的翻譯後，便會產生一個系統設定檔記錄翻譯選擇。

而其他20種新增的代理關鍵字類別(如表~\ref{本論文新增的20種代理關鍵字類別})，皆實作父類別Proxy，負責代理各自對應之原生關鍵字的參數部分翻譯，並將翻譯好的參數部分回傳給對應的原生關鍵字。

\hspace*{\fill} \\

\begin{table}[H]
    \centering
        \begin{tabular}{|l|l|}
        \hline
        \multicolumn{2}{|c|}{新增的代理關鍵字類别} \\ \hline
        1. AlertShouldBePresentProxy & 11. ListShouldNotContainDuplicatesProxy\\ 
        2. CountValuesInListProxy & 12. RemoveFromDictionaryProxy\\ 
        3. DictionariesShouldBeEqualProxy & 13. RemoveValuesFromListProxy\\
        4. DictionaryShouldContainItemProxy & 14. SelectFromListByLabelProxy\\
        5. DictionaryShouldContainKeyProxy & 15. SelectFromListByValueProxy\\
        6. DictionaryShouldContainValueProxy & 16. TableCellShouldContainProxy\\
        7. GetMatchCountProxy & 17. TableColumnShouldContainProxy\\
        8. ListSelectionShouldBeProxy & 18. TableRowShouldContainProxy\\
        9. ListShouldContainSubListProxy & 19. TableShouldContainProxy\\
        10. ListShouldContainValueProxy & 20. TitleShouldBeProxy\\   
        \hline
        \end{tabular}
    \caption{本論文新增的20種代理關鍵字類別}
    \label{本論文新增的20種代理關鍵字類別}
\end{table}

系統執行流程相較於第一版i18n改動較大的部份，是在測試腳本結束後；除了將一詞多譯的warning資訊顯示在報表上外，若是遭遇過一詞多譯，便會跳出一詞多譯的UI(詳見3-4節)，記錄了執行翻譯當下關鍵字的參數組合，並顯示所有可能的翻譯詞，讓使用者可以從中去選擇並產生一個設定檔。之後再次執行測試腳本時，系統便會根據設定檔的內容去選擇適當的翻譯詞，同時消除報表上的warning提示資訊。

\hspace*{\fill} \\
\\ \hspace*{\fill} \\

%3.2
\section{擴充與修改代理關鍵字實作}
第一版i18n工具只支援7種Robot Framework原生關鍵字(如表~\ref{第一版i18n已提供的原生關鍵字})\cite{i18n}。尚有31種參數部分需要翻譯的原生關鍵字，未提供支援。如果測試腳本使用到這些未支援的原生關鍵字去執行多國語言網頁測試，則會導致出錯。因此，本論文的解法是擴充完目前Robot Framework版本剩下的代理關鍵字，使得有翻譯需求的原生關鍵字，其參數部分都能正確的被翻譯。

\renewcommand\arraystretch{0.8}
\begin{table}[H]
    \centering
    \setlength{\tabcolsep}{10mm}{
        \begin{tabular}{|l|}
        \hline
        第一版i18n已提供代理的關鍵字 \\
        \hline
        1. find\_element \\
        2. element\_text\_should\_be \\
        3. lists\_should\_be\_equal\\
        4. should\_be\_equal\\
        5. should\_not\_be\_equal\\
        6. should\_contain\\
        7. should\_not\_contain\\       
        \hline
        \end{tabular}}
    \caption{第一版i18n已提供代理的Robot Framework原生關鍵字}
    \label{第一版i18n已提供的原生關鍵字}
\end{table}

且又因為先前的i18n工具分別在Robot Framework版本3.0.4、SeleniumLibrary版本3.1.1下開發，而現在的Robot Framework版本已更新到3.2.2，SeleniumLibrary版本則更新到4.5.0，導致原先需要被支援的31種原生關鍵字，有兩種已被淘汰:
input\_text\_into\_prompt、xpath\_should\_match\_x\_times。因此，還有29種原生關鍵字需要提供代理(如表~\ref{新版i18n將擴充代理的Robot Framework原生關鍵字})。(‘*’標示為因版本更新導致被淘汰的原生關鍵字)

\begin{table}[H]
    \centering 
    \setlength{\tabcolsep}{5mm}{
        \begin{tabular}{|l|l|}
        \hline
        \multicolumn{2}{|c|}{待擴充的代理關鍵字}\\ \hline
        Collections Libaray (3.2.2) & SeleniumLibrary (4.5.0) \\ \hline
        1. count\_values\_in\_list & 1. alert\_should\_be\_present \\
        2. dictionaries\_should\_be\_equal & 2. input\_text\_into\_alert \\
        3. dictionary\_should\_contain\_item & 3. *input\_text\_into\_prompt\\    
        4. dictionary\_should\_contain\_sub\_dictionary & 4. *xpath\_should\_match\_x\_times\\    
        5. dictionary\_should\_contain\_key & 5. list\_selection\_should\_be\\    
        6. dictionary\_should\_not\_contain\_key & 6. select\_from\_list\_by\_label\\    
        7. dictionary\_should\_contain\_value & 7. unselect\_from\_list\_by\_label\\    
        8. dictionary\_should\_not\_contain\_value & 8. select\_from\_list\_by\_value\\    
        9. list\_should\_contain\_sub\_list & 9. unselect\_from\_list\_by\_value\\    
        10. list\_should\_contain\_value & 10. title\_should\_be\\    
        11. list\_should\_not\_contain\_value & 11. table\_should\_contain\\    
        12. list\_should\_not\_contain\_duplicates & 12. table\_header\_should\_contain\\    
        13. remove\_from\_dictionary & 13. table\_footer\_should\_contain\\    
        14. remove\_values\_from\_list & 14. table\_cell\_should\_contain\\    
        15. get\_match\_count & 15. table\_column\_should\_contain\\
        & 16. table\_column\_should\_contain\\
        \hline
        \end{tabular}}
    \caption{新版i18n將擴充代理的Robot Framework原生關鍵字}
    \label{新版i18n將擴充代理的Robot Framework原生關鍵字}
\end{table}
以下將以 FindElementsProxy的Flow Chart為例，詳述現今配合新增的一詞多譯UI下，本論文是如何完成代理關鍵字的擴充和修改。(沿用第一版i18n的部分會以‘*’號標註)

\begin{figure}[H]
    \includegraphics[width= .85\textwidth]{../UML/i18n flow chart-FindElementsProxy.png}
    \caption{FindElementsProxy的Flow Chart}
    \label{FindElementsProxy的Flow Chart}
\end{figure}

由圖~\ref{FindElementsProxy的Flow Chart} FindElementProxy的Flow Chart可以得知，在新的i18n版本下，擴充一個新的代理關鍵字必須遵從著以下步驟:(以下編號可對應到Flow Chart的數字)
\begin{itemize}
\item[1 .]創出該次關鍵字呼叫的參數紀錄變數，full\_args。此變數之後會成為判斷當下待翻譯詞是否「已被使用者選擇翻譯」的依據。並於測試腳本結束後，顯示於一詞多譯UI上，最後隨著使用者的選擇一併存入設定檔內。

\item[2*.]執行翻譯。如:
\begin{lstlisting}[language={python}]
locator = i18n.I18nListener.MAP.locator(value,full_args)
\end{lstlisting}
透過i18nListener類別的MAP變數(其內裝著i18nMap類別的初始化資訊)，去呼叫i18nMap類別的locator函式，對待翻譯詞value執行翻譯，且必須代入full\_args以實現1.的內容。

\item[3*.]若判定此代理關鍵字遭遇一詞多譯，則產生warning資訊於報表上，如:
\begin{lstlisting}[language={python}]
FindElementsProxy.show_warning(value,multi_trans_words,full_args)
\end{lstlisting}

\item[4 .]之後判斷此一詞多譯情況，最後會使測試通過或是失敗，如:
\begin{lstlisting}[language={python}]
is_actual = BuiltIn().run_keyword_and_return_status('Get WebElement', translation_locator)
if is_actual:
\end{lstlisting}

\item[5 .]若測試會通過，則對預計開啟的UI做一些資料的準備，如:
\begin{lstlisting}[language={python}]
i18n.I18nListener.Is_Multi_Trans=True
if str(full_args)+multiple_translation_words[0] not in ui.UI.unique_log
ui.UI.origin_xpaths_or_arguments.append(full_args)
ui.UI.add_trans_info(self, multiple_translation_words, word_translation, full_args, func.__name__)
\end{lstlisting}
先設定再測試結束後，需要開啟一詞多譯UI。若該「參數+翻譯詞」組合尚未被翻譯過，則記錄下該次翻譯的參數部分和翻譯資訊。

\item[6*.]若此次代理關鍵字沒有遭遇一詞多譯，則如:
\begin{lstlisting}[language={python}]
xpath = locator[0]
\end{lstlisting}
將第一筆翻譯同時也是唯一一筆翻譯指派給之後要回傳的xpath。

\item[7*.]將翻譯好的參數部分回傳給Robot Framework原生關鍵字，如:
\begin{lstlisting}[language={python}]
return func(self, by, BuiltIn().replace_variables(xpath))
\end{lstlisting}
\end{itemize}

其他未能一一介紹的代理關鍵字，儘管彼此間實作仍然存在著差異，但都是遵循著以上的架構去設計。


\hspace*{\fill} \\
\\ \hspace*{\fill} \\
\\ \hspace*{\fill} \\
\\ \hspace*{\fill} \\
\\ \hspace*{\fill} \\
\\ \hspace*{\fill} \\
\\ \hspace*{\fill} \\
\\ \hspace*{\fill} \\
%3.3
\section{改善XPath翻譯邏輯使其能應對各種HTML屬性}
在第一版i18n的翻譯邏輯中，若一個XPath內部存在多種HTML屬性，i18n工具使用了列舉法(如圖~\ref{以列舉法定義要被翻譯的HTML屬性})，僅提供了@title、text()、normalize-space()三種屬性的翻譯規則。屆時，若測試腳本的XPath是用沒有列舉出來的屬性撰寫，但卻有翻譯的需求，例如:@placeholder、@arial-label等等，則會導致測試出錯。

\begin{figure}[H]
\begin{lstlisting}[language={python}]
default_rule = {
'((text|normalize-space)\((text\(\))?\) ?= ?(\'|\")(([0-9a-zA-Z.?&()]| )+)(\'|\"))': 4,
'((text|normalize-space)\((text\(\))?\)\, ?(\'|\")(([0-9a-zA-Z.?&()]| )+)(\'|\"))': 4,
'((@title) ?= ?(\'|\")(([0-9a-zA-Z.?&()]| )+)(\'|\"))' : 3,
'((@title), ?(\'|\")(([0-9a-zA-Z.?&()]| )+)(\'|\"))' : 3
}
\end{lstlisting}
\caption{以列舉法定義要被翻譯的HTML屬性}
\label{以列舉法定義要被翻譯的HTML屬性}
\end{figure}

為了解決以上問題，本論文最後決定採用「負面表列法」，將確定不會執行翻譯的HTML屬性在程式中用list的方式儲存。若XPath中的HTML屬性不在該list中，則都去執行翻譯檢查。

此種作法相較於把所有HTML屬性都執行翻譯檢查，顧及到了系統執行效能，來的更加省時。相較於設計一個複雜邏輯，來訓練系統自行判斷當前HTML屬性是否要翻譯，在實作上則更為簡單，且把翻譯的決定權交給了測試者，而非全部靠系統。相較於第一版i18n，把翻譯規則用列舉法固定，此作法則更能顧及到未來測試腳本的不確定性，因為我們無法預期使用者會用怎麼樣的方式去編寫XPath。

以下將以新版i18n XPath翻譯邏輯的Sequence Diagram為例(如圖~\ref{新版i18n XPath翻譯邏輯的Sequence Diagram})，輔以部分程式碼，詳述系統是如何根據當下情況，產生一套新的翻譯邏輯，以解決先前某些HTML屬性無法被翻譯的問題。

\begin{figure}[H]
    \includegraphics[width= 1.1\textwidth]{../UML/i18n sequence diagram-xpath翻譯邏輯.png}
    \caption{新版i18n XPath翻譯邏輯的Sequence Diagram}
    \label{新版i18n XPath翻譯邏輯的Sequence Diagram}
\end{figure}

首先，被呼叫後，FindElementsProxy透過I18nListener類別，呼叫I18nMap類別的locator()函式執行XPath的翻譯。之後，I18nMap先定義一個內含HTML屬性特徵的rule\_for\_filter變數，如:
\begin{lstlisting}[language={python}]
rule_for_filter = {
    "(@[a-z-]*)":"@",
    "([a-z-]*\(\))":"()"
}
\end{lstlisting}
隨後呼叫find\_all\_match\_word()函式，來過濾出XPath中包含的所有屬性。

接著，先判斷這些屬性是否包含在「不需被翻譯屬性」的list中。如:
\begin{lstlisting}[language={python}]
for rule, matches in all_match_attributes.items():
    for match in matches:
        if match not in self.no_need_trans_attirbutes:
\end{lstlisting}
若不包含其中，則根據屬性含有 ‘@’ 或 ‘()’，分別分配給rule\_for\_at和rule\_for\_bracket變數，並呼叫combine\_locate\_rule()函式，得到一套新的翻譯邏輯，locate\_rule。

之後，再次呼叫find\_all\_match\_word()函式，得到所有符合新翻譯邏輯的HTML屬性，all\_match\_words。並利用迴圈遍歷all\_match\_words中的屬性，執行translate()函式，進行翻譯檢查。
	
接著，判斷經過翻譯後，原先的xpath是否發生變化；例如xpath從原本的 //*[text()=‘Software']，變成了翻譯後的//*[text()=‘軟體']。若xpath改變，則執行log\_translation\_info()函式，將翻譯資訊顯示於測試報表上。

最後，將翻譯後的translated\_xpath，回傳給FindElementsProxy類別，完成一次XPath的翻譯。

\hspace*{\fill} \\
\\ \hspace*{\fill} \\
\\ \hspace*{\fill} \\
\\ \hspace*{\fill} \\
\\ \hspace*{\fill} \\
\\ \hspace*{\fill} \\
\\ \hspace*{\fill} \\
%3.4
\section{提供圖形化使用者介面解決一詞多譯的問題}
先前遇到一詞多譯問題時，第一版i18n工具提供了warning資訊於測試結束後的報表上，此作法確實提醒了使用者該腳本存在著一詞多譯問題，且也顯示出目前系統採用的翻譯詞，這是好的部分，本論文將繼續沿用。此翻譯邏輯是站在一個「最大化讓測試腳本通過」的立場，當遭遇一詞多譯時，系統會將所有的翻譯都執行看看，直到一包可能的翻譯中，出現了一個會使測試通過的翻譯，則算測試通過，並將該翻譯詞呈現於報表上。

然而，以上作法卻存在著一個缺陷，即是「使用者無法自由的選擇真正想要的翻譯詞」去執行腳本測試，而把決定全權授予系統。並有機會產生以下兩點問題:
\begin{itemize}
\item[1.]假如存在「多個翻譯都會使測試通過」，翻譯過後的腳本測試對象，就有機會偏離使用者原先的預期。其原因可能是XPath使用contains撰寫，使得翻譯只要包含特定詞即會讓測試通過。如: 翻譯過後的XPath為//*[@id= ‘supHomeAndLandingPageHeaderContainer]//*[contains(@text, ‘支援’)]，而畫面上待驗證的元件顯示的詞是「支援服務」，測試會通過，但遺憾的是使用者預期‘Support’在此處應該要被翻譯為「支援服務」。
 
\hspace{5mm} 又或是畫面上同時存在含有不同翻譯的元件，且滿足測試腳本的XPath，而導致測試通過。如: 畫面上兩個元件，分別顯示「支援」與「支援服務」；原本使用者預期要驗證的是畫面上存在「支援服務」字樣，但因為‘Support’先被系統檢查的翻譯為「支援」，導致翻譯後的XPath //*[@text= ‘支援’]率先通過了測試，而不會再去檢驗後續的翻譯。 
\item[2.]假如此測試腳本原先就會發生錯誤，經過翻譯後的XPath卻因為碰巧滿足畫面上的某個元件，而導致測試通過。在此特殊情形下，翻譯過後的測試對象，則更明顯的偏離了使用者原先的預期，且也改變了測試結果。如: 原腳本要驗證 //*[@text='Service']，測試會失敗，但經過翻譯後XPath變成//*[@text= ‘支援服務’]，測試卻會通過，因為畫面上剛好存在「支援服務」字樣。
\end{itemize}

所以，本論文將提供一個圖形化使用者介面，記錄下執行翻譯時當下的關鍵字參數組合，並顯示所有可能的翻譯詞，讓使用者從中去選擇，並產生一個設定檔，以便之後再次執行同一測試腳本時，根據設定檔的內容去選擇適當的翻譯詞。期望透過如此的方法來改善上述兩點一詞多譯所遭遇的問題。

以下，將透過圖表和Sequence Diagram的方式，來詳述一詞多譯UI的介面設計與整體實作:

一詞多譯UI的介面設計(如圖~\ref{一詞多譯UI的介面設計})，本論文將其設計成兩個區塊，上半部以條列的方式呈現完整的翻譯資訊，包含關鍵字名稱、參數部分、待翻譯詞、可能的翻譯。其中，參數部分記錄了當前關鍵字接受的使用者傳入參數，以作為和其他相同待翻譯詞的區別；因為相同的待翻譯詞，在不同情況下，可能擁有不同的翻譯。下半部包含一行功能資訊的提示、一個用於開啟翻譯紀錄頁面的TransRecord按鈕，以及提交使用者選擇並寫入設定檔的Submit按鈕。
\begin{figure}[H]
    \centering
    \includegraphics[width= 1.1\textwidth]{../論文截圖/3-4-1一詞多譯UI介面設計.png}
    \caption{一詞多譯UI的介面設計}
    \label{一詞多譯UI的介面設計}
\end{figure}

翻譯紀錄的介面設計(如圖~\ref{翻譯紀錄的介面設計})，本論文同樣將其設計成兩個區塊，上半部以條列式呈現設定檔中現存的使用者翻譯選擇。下半部包含一個Undo按鈕，考量到使用者可能不小心選錯了翻譯，用於將使用者的選擇從設定檔中刪除。
\begin{figure}[H]
    \centering
    \includegraphics[width= .9\textwidth]{../論文截圖/3-4-2 翻譯紀錄介面設計.png}
    \caption{翻譯紀錄的介面設計}
    \label{翻譯紀錄的介面設計}
\end{figure}

一詞多譯UI的實作，大致可以分成8個部分: run()、draw\_trans\_options()、get\_transdic\_keys\_and\_values()、open\_record()、undo\_trans()、output\_setting\_file()、\\add\_trans\_info()、add\_keyword\_name()。各實作彼此之間的互動關係，則如圖~\ref{產生一詞多譯UI的sequence diagram}:
\hspace*{\fill} \\

\begin{figure}[H]
    \centering
    \includegraphics[width= \textwidth]{../UML/i18n sequence diagram-一詞多譯UI.png}
    \caption{產生一詞多譯UI的sequence diagram}
    \label{產生一詞多譯UI的sequence diagram}
\end{figure}

當測試腳本結束時，會呼叫I18nListener類別的end\_suite()函式。

若本次測試腳本遭遇一詞多譯，則呼叫UI類別，使其初始化並執行run()函式，產生一詞多譯UI的介面，包含“Choose the translation(s) you want!!” 字樣、顯示翻譯紀錄的 TransRecord按鈕，以及寫入使用者選擇的Submit按鈕。之後，run()函式內部會呼叫draw\_trans\_options()函式，其內會再呼叫get\_transdic\_keys\_and\_values()函式，取出待翻譯詞與其對應的翻譯，最後隨著翻譯當下的關鍵字名稱和參數部分一併顯示於一詞多譯UI的介面上。

在一詞多譯介面上，點擊TransRecord按鈕會呼叫open\_record()函式，打開翻譯紀錄介面，其會將先前使用者選擇過的翻譯詞，以條列式的方式呈現，且介面上還包含一顆Undo按鈕。點擊Undo按鈕會呼叫undo\_trans()函式，將使用者選擇的翻譯紀錄從設定檔中清除掉，同時關閉翻譯紀錄頁面。

在一詞多譯介面上，點擊Submit按鈕則會呼叫output\_setting\_file()函式，將使用者選擇的待翻譯詞對應其翻譯以及完整參數寫入設定檔“i18n/listeners/setting.txt”中，同時將剛剛已寫入的翻譯資訊從一詞多譯UI上隱藏。

此外，在UI類別中定義的add\_translations()和add\_keyword\_name()函式，雖然不會在一詞多譯UI執行期間被呼叫，但在測試腳本執行期間，卻能負責將代理關鍵字傳入的關鍵字名稱、待翻譯詞，與其對應翻譯，分別儲存於變數中，方便之後一詞多譯UI的讀取。並且，還會將關鍵字的參數部分和待翻譯詞結合，成為可以辨別「該次測試腳本是否執行過相同翻譯」的字串，存入unique\_log變數中。

\hspace*{\fill} \\
\\ \hspace*{\fill} \\

%3.5
\section{將i18n工具設計成為可以安裝的模組}
本論文透過Python的build模組，將i18n工具包裝成名為“RF-i18n-tool”的Library，並透過twine模組上傳至PYPI\cite{PYPI}網站上，使之成為可以直接讓使用者安裝的Python模組。解決了先前使用者只能從github上將i18n工具clone下來，並在該專案上開發測試腳本的不方便。

以下將詳述將i18n包裝成Python模組的步驟:

在將i18n工具打包成為一個Library前，必須先準備以下五個檔案: setup.cfg、pyproject.toml、README.md、LICENSE\cite{license}、MANIFEST.in。此外必須確認將打包的資料夾下，包含\_\_init\_\_.py檔案，以被系統辨識為一個Python模組。

上述的檔案準備就緒後，便可以在i18n專案目錄下執行python –m build 指令，待建置完畢，便會產生一個名為dist的資料夾，裡面裝著打包好的RF-i18n-tool模組檔案。接下來執行python –m twine upload - -repository pypi dist/* 指令，輸入帳號密碼後，便能成功將dist資料夾中的RF-i18n-tool模組上傳至PYPI了。之後在PYPI網站上搜尋RF-i18n-tool，便能看到上傳的模組。

使用者若要安裝此模組，只需執行pip install RF-i18n-tool 指令即可(如圖3.11)。

\begin{figure}[H]
    \centering
    \includegraphics[width= .5\textwidth]{../論文截圖/3-5-8 安裝RF-AWT-i18n指令.png}
    \caption{安裝RF-i18n-tool指令}
\end{figure}

\hspace*{\fill} \\
\\ \hspace*{\fill} \\

最後，使用者便可透過在Additional Robot Framework arguments中設定系統參數(如圖~\ref{以i18n預設JSON翻譯檔來執行i18n工具}、~\ref{以使用者提供的JSON翻譯檔來執行i18n工具})，來使用i18n工具。自定義的JSON翻譯檔路徑必須遵守以下格式(如圖~\ref{JSON翻譯檔路徑格式})

\begin{figure}[H]
\begin{lstlisting}[language={python}]
-d out -L debug --listener %YOUR_PYTHON_PATH%/Lib/site-packages/i18n/listeners/I18nListener.py:YOUR_LOCALE:i18njson
\end{lstlisting}
\caption{以i18n預設JSON翻譯檔來執行i18n工具}
\label{以i18n預設JSON翻譯檔來執行i18n工具}
\end{figure}

\begin{figure}[H]
\begin{lstlisting}[language={python}]
-d out -L debug --listener %YOUR_PYTHON_PATH%/Lib/site-packages/i18n/listeners/I18nListener.py:YOUR_LOCALE
\end{lstlisting}
\caption{以使用者提供的JSON翻譯檔來執行i18n工具}
\label{以使用者提供的JSON翻譯檔來執行i18n工具}
\end{figure}

\begin{figure}[H]
\begin{lstlisting}[language={python}]
YOUR_PROJECT_DIR/languageFiles/YOUR_LOCALE(ex:zh-TW)/xxxYOUR_LOCALE.json
\end{lstlisting}
\caption{JSON翻譯檔路徑格式}
\label{JSON翻譯檔路徑格式}
\end{figure}